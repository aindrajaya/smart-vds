// File containing functions that detect vulnerabilities; each function corresponds to one type of vulnerability
const jsonpath = require('jsonpath')

module.exports = {
  detectReentrancy: (parseTree) => {
    const vulnerableFunctionCalls = []
    const vulnerableFuncIndexes = []

    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const functionCalls = []
      const assignmentOps = []
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement, index) => {
        // Extracts all function calls from statement
        const statementFunctionCalls = jsonpath.query(statement, '$..[?(@.type=="FunctionCall")]')
        if (statementFunctionCalls.length > 0) {
          statementFunctionCalls.forEach((functionCall) => {
            if (functionCall.expression.name !== 'require') {
              functionCalls.push({ index, statement })
            }
          })
        } else {
          const statementAssignOps = jsonpath.query(statement, '$..[?(@.type=="BinaryOperation" && (@.operator=="=" || @.operator=="+=" || @.operator=="-="))]')
          if (statementAssignOps) {
            assignmentOps.push({ index, statement })
          }
        }
      })
      functionCalls.forEach((functionCall) => {
        assignmentOps.forEach((assignmentOp) => {
          if (functionCall.index < assignmentOp.index && !(vulnerableFuncIndexes.includes(functionCall.index))) {
            vulnerableFuncIndexes.push(functionCall.index)
            vulnerableFunctionCalls.push(functionCall)
          }
        })
      })
    })
    return vulnerableFunctionCalls
  },

  detectOutdatedCompilerVersion: (parseTree) => {
    let outdatedPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value !== '^0.8.9' && pragmaDirective[0].value !== '0.8.9') {
      outdatedPragmaDirective = pragmaDirective[0]
    }
    return outdatedPragmaDirective
  },

  detectFloatingPragma: (parseTree) => {
    let floatingPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value.includes('^')) {
      floatingPragmaDirective = pragmaDirective[0]
    }
    return floatingPragmaDirective
  },

  detectTransferAndSend: (parseTree) => {
    const transferOrSendCalls = []
    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement) => {
        const detectedCalls = jsonpath.query(statement, '$..[?(@.memberName=="transfer" || @.memberName=="send")]')
        if (detectedCalls.length > 0) {
          transferOrSendCalls.push(statement)
        }
      })
    })
    return transferOrSendCalls
  }
}
