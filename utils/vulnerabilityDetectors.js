// File containing functions that detect vulnerabilities; each function corresponds to one type of vulnerability
const jsonpath = require('jsonpath')
const { JSONPath } = require('jsonpath-plus')

module.exports = {
  detectReentrancy: (parseTree, patterns) => {
    const vulnerableFunctionCalls = []
    const vulnerableFuncIndexes = []

    const functionDefinitions = jsonpath.query(parseTree, patterns[0])
    functionDefinitions.forEach((funcDef) => {
      const functionCalls = []
      const assignmentOps = []
      const statements = jsonpath.query(funcDef, patterns[1])[0]
      statements.forEach((statement, index) => {
        // Extracts all function calls from statement
        const statementFunctionCalls = jsonpath.query(statement, patterns[2])
        if (statementFunctionCalls.length > 0) {
          statementFunctionCalls.forEach((functionCall) => {
            if (functionCall.expression.name !== 'require') {
              functionCalls.push({ index, statement })
            }
          })
        } else {
          const statementAssignOps = jsonpath.query(statement, patterns[3])
          if (statementAssignOps) {
            assignmentOps.push({ index, statement })
          }
        }
      })
      functionCalls.forEach((functionCall) => {
        assignmentOps.forEach((assignmentOp) => {
          if (functionCall.index < assignmentOp.index && !(vulnerableFuncIndexes.includes(functionCall.index))) {
            vulnerableFuncIndexes.push(functionCall.index)
            vulnerableFunctionCalls.push(functionCall)
          }
        })
      })
    })
    return vulnerableFunctionCalls
  },

  detectOutdatedCompilerVersion: (parseTree, patterns) => {
    let outdatedPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, patterns[0])
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value !== '^0.8.9' && pragmaDirective[0].value !== '0.8.9') {
      outdatedPragmaDirective = pragmaDirective[0]
    }
    return outdatedPragmaDirective
  },

  detectFloatingPragma: (parseTree) => {
    let floatingPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value.includes('^')) {
      floatingPragmaDirective = pragmaDirective[0]
    }
    return floatingPragmaDirective
  },

  detectTransferAndSend: (parseTree, patterns) => {
    const transferOrSendCalls = []
    const functionDefinitions = jsonpath.query(parseTree, patterns[0])
    functionDefinitions.forEach((funcDef) => {
      const statements = jsonpath.query(funcDef, patterns[1])[0]
      statements.forEach((statement) => {
        const detectedCalls = jsonpath.query(statement, patterns[2])
        if (detectedCalls.length > 0) {
          transferOrSendCalls.push(statement)
        }
      })
    })
    return transferOrSendCalls
  },

  detectUncheckedCallReturnValue: async (parseTree, patterns) => {
    let uncheckedCallReturnValues = []
    let object = parseTree

    for (let i = 0; i < patterns.length; i++) {
      object = JSONPath({ json: object, path: patterns[i], resultType: 'value' })
    }
    uncheckedCallReturnValues = object
    return uncheckedCallReturnValues
  }
}
