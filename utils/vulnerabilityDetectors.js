// File containing functions that detect vulnerabilities; each function corresponds to one type of vulnerability
const jsonpath = require('jsonpath')
const { JSONPath } = require('jsonpath-plus')

module.exports = {
  detectReentrancy: (parseTree) => {
    const vulnerableFunctionCalls = []
    const vulnerableFuncIndexes = []

    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const functionCalls = []
      const assignmentOps = []
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement, index) => {
        // Extracts all function calls from statement
        const statementFunctionCalls = jsonpath.query(statement, '$..[?(@.type=="FunctionCall")]')
        if (statementFunctionCalls.length > 0) {
          statementFunctionCalls.forEach((functionCall) => {
            if (functionCall.expression.name !== 'require') {
              functionCalls.push({ index, statement })
            }
          })
        } else {
          const statementAssignOps = jsonpath.query(statement, '$..[?(@.type=="BinaryOperation" && (@.operator=="=" || @.operator=="+=" || @.operator=="-="))]')
          if (statementAssignOps) {
            assignmentOps.push({ index, statement })
          }
        }
      })
      functionCalls.forEach((functionCall) => {
        assignmentOps.forEach((assignmentOp) => {
          if (functionCall.index < assignmentOp.index && !(vulnerableFuncIndexes.includes(functionCall.index))) {
            vulnerableFuncIndexes.push(functionCall.index)
            vulnerableFunctionCalls.push(functionCall)
          }
        })
      })
    })
    return vulnerableFunctionCalls
  },

  detectOutdatedCompilerVersion: (parseTree) => {
    let outdatedPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value !== '^0.8.9' && pragmaDirective[0].value !== '0.8.9') {
      outdatedPragmaDirective = pragmaDirective[0]
    }
    return outdatedPragmaDirective
  },

  detectFloatingPragma: (parseTree) => {
    let floatingPragmaDirective = {}
    const pragmaDirective = jsonpath.query(parseTree, '$.children[?(@.type=="PragmaDirective")]')
    if (pragmaDirective.length !== 1) {
      return { error: 'Smart contract must contain exactly one pragma statement.' }
    } else if (pragmaDirective[0].value.includes('^')) {
      floatingPragmaDirective = pragmaDirective[0]
    }
    return floatingPragmaDirective
  },

  detectTransferAndSend: (parseTree) => {
    const transferOrSendCalls = []
    const functionDefinitions = jsonpath.query(parseTree, '$..subNodes[?(@.type=="FunctionDefinition")]')
    functionDefinitions.forEach((funcDef) => {
      const statements = jsonpath.query(funcDef, '$.body.statements')[0]
      statements.forEach((statement) => {
        const detectedCalls = jsonpath.query(statement, '$..[?(@.memberName=="transfer" || @.memberName=="send")]')
        if (detectedCalls.length > 0) {
          transferOrSendCalls.push(statement)
        }
      })
    })
    return transferOrSendCalls
  },

  detectUncheckedCallReturnValue: (parseTree) => {
    let uncheckedCallReturnValues = []
    // Vulnerability patterns for Unchecked Call Return Value
    const uncheckedStatements = '$..statements[?(@.type != "IfStatement" && @.type != "ReturnStatement" && ' +
        '@.type != "VariableDeclarationStatement")]'
    const lowLevelFunctionCalls = '$..expression[?(@.type != "FunctionCall" && (@.memberName == "call" || @.memberName == "send" || ' +
        '@.memberName == "delegatecall" || @.memberName == "callcode"))]'

    // JSON Queries for pattern matching
    const q1 = JSONPath({ json: parseTree, path: uncheckedStatements, resultType: 'value' })
    const q2 = JSONPath({ json: q1, path: lowLevelFunctionCalls, resultType: 'value' })
    uncheckedCallReturnValues = [q2.length > 0, q2]

    return uncheckedCallReturnValues
  },


  detectTXOrigin: (parseTree) => {
    // Patterns to detect Tx.Origin
    const TXOriginPattern = [
      '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ExpressionStatement")].expression.arguments[?((@.type=="BinaryOperation") && (@.operator == "==") && (@.left.expression.name == "tx") && (@.left.memberName == "origin"))]',
      '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ExpressionStatement")].expression.arguments[?((@.type=="BinaryOperation") && (@.operator == "==") && (@.right.expression.name == "tx") && (@.right.memberName == "origin"))]',
      '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "BinaryOperation") && (@.expression.left.name =="owner") && (@.expression.right.memberName == "origin") && (@.expression.right.expression.name == "tx"))]'
    ]

    const detectedPattern = []

    // check JSON with all TXOriginPattern, if any pattern is matched, we will return value 1, else return 0
    for (let i = 0; i < TXOriginPattern.length; i++) {
      const returnvalue = jsonpath.query(parseTree, TXOriginPattern[i])
      if (returnvalue.length !== 0) {
        detectedPattern.push(returnvalue)
      }
    }
    // console.log(detected_pattern)
    if (detectedPattern.length > 0) {
      return [1, detectedPattern]
    } else {
      return [0, []]
    }
  },

  detectUnderFlow: (parseTree) => {
<<<<<<< HEAD
    const detectedPattern = []
=======
    const detected_Pattern = []
>>>>>>> 9f161da9d3e7f61d862fbffa5748c28c0f0d252c

    // If any expression is handled in If statement, then it is mentioned in trueBody statement. If it is not, then we can say, it is mentioned outside the If condition where boundary conditions are not handled, it's vulnerability for us. So we will directly push those statements in our detected_pattern array
    const statement = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "BinaryOperation") && (@.expression.right.operator == "-") )]')
    for (let i = 0; i < statement.length; i++) {
      detectedPattern.push(statement[i])
    }

    // Now, we are considering scenario where our expression is mentioned in If statement, but not handled in If condition
    const ifStatementQuery = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "IfStatement")]')
    for (let i = 0; i < ifStatementQuery.length; i++) {
      const ifStatement = ifStatementQuery[i]
      if (ifStatement.length !== 0) {
        const checkVariableinifstatement = jsonpath.query(ifStatement, '$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "-") )].expression.right.left.name')

        const checkVariableinifcondition = jsonpath.query(ifStatement, '$..[?((@.type == "BinaryOperation") && (@.operator == ">=") && (@.right.number == "0"))].left.left.name')

        if ((checkVariableinifcondition.length >= 0) && (checkVariableinifstatement.length >= 0)) {
          if (checkVariableinifstatement[0] !== checkVariableinifcondition[0]) {
            const statementInif = jsonpath.query(ifStatement, '$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "-") )].expression')
            detectedPattern.push(statementInif)
          }
        }
        // console.log(detected_pattern)
      }
    }

    // Now, we are considering scenario where our expression is mentioned in While loop, but not checked in While condition
    const whileStatementQuery = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "WhileStatement")]')
    for (let i = 0; i < whileStatementQuery.length; i++) {
      const whileStatement = whileStatementQuery[i]
      if (whileStatement.length !== 0) {
        const checkVariableinwhilestatement = jsonpath.query(whileStatement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "--") )].expression.subExpression.name')
        const checkVariableinwhilecondition = jsonpath.query(whileStatement, '$..[?((@.type=="BinaryOperation") && (@.operator == ">=") && (@.right.number == "0") )].left.name')

        if ((checkVariableinwhilestatement.length >= 0) && (checkVariableinwhilecondition.length >= 0)) {
          if (checkVariableinwhilestatement[0] !== checkVariableinwhilecondition[0]) {
            const statementInWhile = jsonpath.query(whileStatement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "--") )].expression')
            detectedPattern.push(statementInWhile)
          }
        }
      }
    }

    // Now, we are considering scenario where our expression is mentioned in For loop, but boundary condition is not checked in For condition
    const forStatementquery = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ForStatement")]')
    for (let i = 0; i < forStatementquery.length; i++) {
      const forStatement = forStatementquery[i]
      if (forStatement !== 0) {
        const checkVariableinforstatement = jsonpath.query(forStatement, '$..[?((@.type == "BinaryOperation") && (@.operator == ">=") && (@.right.number == "0") )].left.name')
        const checkVariableinforcondition = jsonpath.query(forStatement, '$..[?((@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "--") )].expression.subExpression.name')
        if ((checkVariableinforstatement.length >= 0) && (checkVariableinforcondition.length >= 0)) {
          if (checkVariableinforstatement[0] !== checkVariableinforcondition[0]) {
            detectedPattern.push(forStatement)
          }
        }
      }
    }

    // console.log(detected_pattern)
    if (detectedPattern.length > 0) {
      return [1, detectedPattern]
    } else {
      return [0, []]
    }
  },

  detectOverFlow: (parseTree) => {
<<<<<<< HEAD
    const detectedPattern = []
=======
    const detected_Pattern = []
>>>>>>> 9f161da9d3e7f61d862fbffa5748c28c0f0d252c

    // If any expression is handled in If statement, then it is mentioned in trueBody statement. If it is not, then we can say, it is mentioned outside the If condition where boundary conditions are not handled, it's vulnerability for us. So we will directly push those statements in our detected_pattern array
    const statement = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?((@.type == "ExpressionStatement") && (@.expression.type == "BinaryOperation") && (@.expression.right.operator == "+") )]')
    for (let i = 0; i < statement.length; i++) {
      detectedPattern.push(statement[i])
    }

    // Now, we are considering scenario where our expression is mentioned in If statement, but not handled in If condition
    const ifStatementquery = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "IfStatement")]')
    for (let i = 0; i < ifStatementquery.length; i++) {
      const ifStatement = ifStatementquery[i]
      if (ifStatement.length !== 0) {
        const checkVariableinifstatement = jsonpath.query(ifStatement, '$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "+") )].expression.right.left.name')
        const checkVariableinifcondition = jsonpath.query(ifStatement, '$..[?((@.type == "BinaryOperation") && (@.operator == "<"))].right.components[?( (@.type == "BinaryOperation") && (@.operator == "-") && (@.left.operator == "**") && (@.left.left.number == "2") && ( (@.left.right.number == "8") || (@.left.right.number == "16") || (@.left.right.number == "32") || (@.left.right.number == "64") || (@.left.right.number == "128")) && (@.right.number == "1") )]')
        const checkVariableinifvariable = jsonpath.query(ifStatement, '$..[?((@.type == "BinaryOperation") && (@.operator == "<"))].left.components[?(@.type=="BinaryOperation")].left.name')

        if (checkVariableinifcondition !== 0) {
          if (checkVariableinifstatement.length !== 0 && checkVariableinifvariable !== 0) {
            if (checkVariableinifstatement[0] !== checkVariableinifvariable[0]) {
              const statementInif = jsonpath.query(ifStatement, '$.trueBody.statements[?( (@.type=="ExpressionStatement") && (@.expression.right.operator == "+") )].expression')
              detectedPattern.push(statementInif)
            }
          }
        }
      }
    }

    // Now, we are considering scenario where our expression is mentioned in While loop, but not checked in While condition
    const whileStatementQuery = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "WhileStatement")]')
    for (let i = 0; i < whileStatementQuery.length; i++) {
      const whileStatement = whileStatementQuery[i]
      if (whileStatement.length !== 0) {
        const checkVariableinwhilestatement = jsonpath.query(whileStatement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "++") )].expression.subExpression.name')
        const checkVariableinwhilecondition = jsonpath.query(whileStatement, '$..[?((@.type=="BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].right.components[?((@.type == "BinaryOperation") && (@.operator == "-") && (@.left.operator == "**") && (@.left.left.number == "2") && ( (@.left.right.number == "8") || (@.left.right.number == "16") || (@.left.right.number == "32") || (@.left.right.number == "64") || (@.left.right.number == "128")) && (@.right.number == "1") )]')
        const checkVariableinwhilevariable = jsonpath.query(whileStatement, '$..[?((@.type=="BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].left.name')

        if (checkVariableinwhilestatement.length !== 0 && checkVariableinwhilevariable.length !== 0) {
          if (checkVariableinwhilestatement[0] !== checkVariableinwhilevariable[0]) {
            const statementInwhile = jsonpath.query(whileStatement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "++") )].expression')
            detectedPattern.push(statementInwhile)
          } else {
            if (checkVariableinwhilecondition === 0) {
              const statementInwhile = jsonpath.query(whileStatement, '$.body.statements[?( (@.type == "ExpressionStatement") && (@.expression.type == "UnaryOperation") && (@.expression.operator == "++") )].expression')
              detectedPattern.push(statementInwhile)
            }
          }
        }
      }
    }

    // Now, we are considering scenario where our expression is mentioned in For loop, but boundary condition is not checked in For condition
    const forStatementquery = jsonpath.query(parseTree, '$..subNodes[?(@.type == "FunctionDefinition")].body.statements[?(@.type == "ForStatement")]')
    for (let i = 0; i < forStatementquery.length; i++) {
      const forStatement = forStatementquery[i]
      if (forStatement !== 0) {
        const checkVariableinforstatement = jsonpath.query(forStatement, '$..[?( (@.type == "BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].right.components[?( (@.type == "BinaryOperation") && (@.operator == "-") && (@.left.operator == "**") && (@.left.left.number == "2") && ((@.left.right.number == "8") || (@.left.right.number == "16") || (@.left.right.number == "32") || (@.left.right.number == "64") || (@.left.right.number == "128")) && (@.right.number == "1") )]')
        const checkVariableinforvariable = jsonpath.query(forStatement, '$..[?( (@.type == "BinaryOperation") && ((@.operator == "<") || (@.operator == "<=")) )].left.name')
        const checkVariableinforcondition = jsonpath.query(forStatement, '$..loopExpression[?((@.type == "UnaryOperation") && (@.operator == "++") )].subExpression.name')
        if (checkVariableinforstatement.length !== 0 && checkVariableinforvariable.length !== 0 && checkVariableinforcondition.length !== 0) {
          if (checkVariableinforvariable[0] !== checkVariableinforcondition[0]) {
            detectedPattern.push(forStatement)
          }
        }
      }
    }

    // console.log(detected_pattern)
    if (detectedPattern.length > 0) {
      return [1, detectedPattern]
    } else {
      return [0, []]
    }
  }
}
