const vulnerabilityDetectors = require('./utils/vulnerabilityDetectors')
const db = require('./utils/databaseUtils')
const chalk = require('chalk')
const { vulnerabilities } = require('./const/vulnerabilities')

module.exports = {
  // Scanner function that runs all vulnerability detectors for a given parse tree
  vulnerabilityScanner: async (parseTree) => {
    try {
      const vulnerabilitiesDetected = []
      const isConnected = await db.isDbConnected()

      if (isConnected) {
        // Authorization through tx.origin
        const authThroughTxOriginPatterns = await db.retrievePatterns(vulnerabilities.AUTH_THROUGH_TX_ORIGIN)
        const authThroughTxOrigin = vulnerabilityDetectors.detectTXOrigin(parseTree, authThroughTxOriginPatterns)

        // Floating Pragma
        const floatingPragmaPatterns = await db.retrievePatterns(vulnerabilities.FLOATING_PRAGMA)
        const floatingPragma = vulnerabilityDetectors.detectFloatingPragma(parseTree, floatingPragmaPatterns)

        // Hardcoded Gas Amount
        const hardcodedGasAmountPatterns = await db.retrievePatterns(vulnerabilities.HARDCODED_GAS_AMOUNT)
        const hardcodedGasAmount = vulnerabilityDetectors.detectTransferAndSend(parseTree, hardcodedGasAmountPatterns)

        // Integer Overflow and Underflow
        const intOverflowPatterns = await db.retrievePatterns(vulnerabilities.INT_OVERFLOW)
        const intOverflow = vulnerabilityDetectors.detectOverFlow(parseTree, intOverflowPatterns)
        const intUnderflowPatterns = await db.retrievePatterns(vulnerabilities.INT_UNDERFLOW)
        const intUnderflow = vulnerabilityDetectors.detectUnderFlow(parseTree, intUnderflowPatterns)

        // Outdated Compiler Version
        const outdatedCompilerVersionPatterns = await db.retrievePatterns(vulnerabilities.OUTDATED_COMPILER_VERSION)
        const outdatedCompilerVersion = vulnerabilityDetectors.detectOutdatedCompilerVersion(parseTree, outdatedCompilerVersionPatterns)

        // Re-entrancy
        const reentrancyPatterns = await db.retrievePatterns(vulnerabilities.REENTRANCY)
        const reentrancy = vulnerabilityDetectors.detectReentrancy(parseTree, reentrancyPatterns)

        // Unchecked Call Return Value
        const uncheckedCallReturnValuePatterns = await db.retrievePatterns(vulnerabilities.UNCHECKED_CALL_RETURN_VALUE)
        const uncheckedCallReturnValue = vulnerabilityDetectors.detectUncheckedCallReturnValue(parseTree, uncheckedCallReturnValuePatterns)

        const vulnerabilityArray = [
          { vid: vulnerabilities.AUTH_THROUGH_TX_ORIGIN, object: authThroughTxOrigin },
          { vid: vulnerabilities.FLOATING_PRAGMA, object: floatingPragma },
          { vid: vulnerabilities.HARDCODED_GAS_AMOUNT, object: hardcodedGasAmount },
          { vid: vulnerabilities.INT_OVERFLOW, object: intOverflow[1] },
          { vid: vulnerabilities.INT_UNDERFLOW, object: intUnderflow[1] },
          { vid: vulnerabilities.OUTDATED_COMPILER_VERSION, object: outdatedCompilerVersion },
          { vid: vulnerabilities.REENTRANCY, object: reentrancy },
          { vid: vulnerabilities.UNCHECKED_CALL_RETURN_VALUE, object: uncheckedCallReturnValue }
        ]

        // Grab detected vulnerabilities
        for (let i = 0; i < vulnerabilityArray.length; i++) {
          if (vulnerabilityArray[i].object.length > 0) {
            vulnerabilitiesDetected.push({ vid: vulnerabilityArray[i].vid, object: vulnerabilityArray[i].object })
          }
        }

        // Display count and details of vulnerabilities found. Will move to generate report function Round 3.
        // console.log('Types of Vulnerabilities Detected: ', vulnerabilitiesDetected.length)
        // console.log('Vulnerabilities: ')
        // for (let i = 0; i < vulnerabilitiesDetected.length; i++) {
        //   console.log(vulnerabilitiesDetected[i].vid + ': ', vulnerabilitiesDetected[i].object.length)
        //   console.log(vulnerabilitiesDetected[i].object)
        // }
        // Will move close db connection to generate report function Round 3.
        await db.closeDbConnection()
        // console.log(chalk.greenBright('Scan complete.'))

        return vulnerabilitiesDetected
      }
    } catch (e) {
      console.log(chalk.red('Scanning error: ', e))
    }
  }
}
