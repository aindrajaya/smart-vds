const vulnerabilityDetectors = require('./utils/vulnerabilityDetectors')
const db = require('./utils/databaseUtils')
const chalk = require('chalk')
const { vulnerabilities } = require('./const/vulnerabilities')

module.exports = {
  // Scanner function that runs all vulnerability detectors for a given parse tree
  vulnerabilityScanner: async (parseTree) => {
    try {
      const vulnerabilitiesDetected = []
      const isConnected = await db.isDbConnected()

      // console.log(isConnected ? chalk.green('Database connected') : chalk.red('Database not connected'))

      if (isConnected) {
        // Re-entrancy
        const reentrancyPatterns = await db.retrievePatterns(vulnerabilities.REENTRANCY)
        // console.log(reentrancyPatterns, "reentrancyPatterns output")
        const reentrancy = vulnerabilityDetectors.detectReentrancy(parseTree, reentrancyPatterns)
        // console.log(reentrancy, "reentrancy output")

        // Floating Pragma
        const floatingPragmaPatterns = await db.retrievePatterns(vulnerabilities.FLOATING_PRAGMA)
        // console.log(floatingPragmaPatterns, "floatingPragmaPatterns output")
        const floatingPragma = vulnerabilityDetectors.detectFloatingPragma(parseTree, floatingPragmaPatterns)

        // Authorization through tx.origin
        const authThroughTxOriginPatterns = await db.retrievePatterns(vulnerabilities.AUTH_THROUGH_TX_ORIGIN)
        // console.log(authThroughTxOriginPatterns, "authThroughTxOriginPatterns output")
        const authThroughTxOrigin = vulnerabilityDetectors.detectTXOrigin(parseTree, authThroughTxOriginPatterns)
        // console.log(authThroughTxOrigin, "authThroughTxOrigin output")

        // Integer Overflow and Underflow
        // const intOverflowPatterns = await db.retrievePatterns(vulnerabilities.INT_OVERFLOW)
        // console.log(intOverflowPatterns, "intOverflowPatterns output")
        // const intOverflow = vulnerabilityDetectors.detectOverFlow(parseTree, intOverflowPatterns)
        // const intUnderflowPatterns = await db.retrievePatterns(vulnerabilities.INT_UNDERFLOW)
        // console.log(intUnderflowPatterns, "intUnderflowPatterns output")
        // const intUnderflow = vulnerabilityDetectors.detectUnderFlow(parseTree, intUnderflowPatterns)

        // Unchecked Call Return Value
        // const uncheckedCallReturnValuePatterns = await db.retrievePatterns(vulnerabilities.UNCHECKED_CALL_RETURN_VALUE)
        // console.log(uncheckedCallReturnValuePatterns, "uncheckedCallReturnValuePatterns output")
        // const uncheckedCallReturnValue = vulnerabilityDetectors.detectUncheckedCallReturnValue(parseTree, uncheckedCallReturnValuePatterns)

        // Hardcoded Gas Amount
        // const hardcodedGasAmountPatterns = await db.retrievePatterns(vulnerabilities.HARDCODED_GAS_AMOUNT)
        // console.log(hardcodedGasAmountPatterns, "hardcodedGasAmountPatterns output")
        // const hardcodedGasAmount = vulnerabilityDetectors.detectTransferAndSend(parseTree, hardcodedGasAmountPatterns)

        //Floating pragma lama

        // Outdated Compiler Version
        // const outdatedCompilerVersionPatterns = await db.retrievePatterns(vulnerabilities.OUTDATED_COMPILER_VERSION)
        // console.log(outdatedCompilerVersionPatterns, "outdatedCompilerVersionPatterns output")
        // const outdatedCompilerVersion = vulnerabilityDetectors.detectOutdatedCompilerVersion(parseTree, outdatedCompilerVersionPatterns)

        const vulnerabilityArray = [
          // { vid: vulnerabilities.REENTRANCY, object: reentrancy },
          { vid: vulnerabilities.AUTH_THROUGH_TX_ORIGIN, object: authThroughTxOrigin },
          // { vid: vulnerabilities.INT_OVERFLOW, object: intOverflow[1] },
          // { vid: vulnerabilities.INT_UNDERFLOW, object: intUnderflow[1] },
          // { vid: vulnerabilities.UNCHECKED_CALL_RETURN_VALUE, object: uncheckedCallReturnValue },
          // { vid: vulnerabilities.HARDCODED_GAS_AMOUNT, object: hardcodedGasAmount },
          { vid: vulnerabilities.FLOATING_PRAGMA, object: floatingPragma },
          // { vid: vulnerabilities.OUTDATED_COMPILER_VERSION, object: outdatedCompilerVersion }
        ]

        // console.log(chalk.green('Vulnerabilities detected: ', vulnerabilityArray?.forEach((v) => console.log(v.vid, v.object))))

        // Grab detected vulnerabilities
        for (let i = 0; i < vulnerabilityArray.length; i++) {
          if (vulnerabilityArray[i].object.length > 0) {
            vulnerabilitiesDetected.push({ vid: vulnerabilityArray[i].vid, object: vulnerabilityArray[i].object })
          }
        }

        return vulnerabilitiesDetected
      }
    } catch (e) {
      console.log(chalk.red('Scanning error: ', e))
    }
  }
}
